# -*- coding: utf-8 -*-
"""
Created on Mon Jun 15 18:05:20 2020

@author: iant
"""
import numpy as np
import matplotlib.pyplot as plt
import spiceypy as sp

import numpy.linalg as la


from tools.file.paths import FIG_X, FIG_Y
from tools.file.hdf5_functions import open_hdf5_file

from tools.spice.load_spice_kernels import load_spice_kernels
from tools.spice.datetime_functions import utc2et

from tools.spice.read_webgeocalc import read_webgeocalc

# load_spice_kernels()
load_spice_kernels()


"""user modifiable"""
# SAVE_FIG = True
SAVE_FIG = False

# interpolate the results onto a contour map?
MESHGRID = False
# MESHGRID = True

# print out ephemeris times so that they can be put into ESA WebGeoCalc?
# PRINT_WGC_ETS = True
PRINT_WGC_ETS = False

# read in WebGeoCalc state vectors from a file. File must be made first from the ephemeris times
# needed for cruise phase calibrations where full kernels are not available
# WGC = True
WGC = False


# path to h5 root directory
HDF5_PATH = r"W:\data\SATELLITE\TRACE-GAS-ORBITER\NOMAD\hdf5"


# select a channel. For SO, plot all the scans in subplots on one figure. LNO/UVIS: plot one at a time
# channel = "so"
channel = "uvis"
# channel = "lno"


"""end user modifiable options"""


SPICE_ABERRATION_CORRECTION = "None"
SPICE_OBSERVER = "-143"

DETECTOR_CENTRE_LINES = {"so": 128, "lno": 152}

grid_size = 0.005

# for lno and uvis, just select one at a time!
linescan_dict = {
    "so": {
        # "Initial boresight (Nov 2016)": ["20161120_231420_0p1a_SO_1", "20161121_012420_0p1a_SO_1"],
        # "Mission start (Apr 2018)": ["20180428_023343_0p1a_SO_1", "20180511_084630_0p1a_SO_1"],
        # "UVIS-prime (Aug 2018)": ["20180821_193241_0p1a_SO_1", "20180828_223824_0p1a_SO_1"],
        # "UVIS-prime (Dec 2018)": ["20181219_091740_0p1a_SO_1", "20181225_025140_0p1a_SO_1"],  # not a nomad linescan
        # "UVIS-prime (Jan 2019)": ["20190118_183336_0p1a_SO_1", "20190125_061434_0p1a_SO_1"],
        # "SO-prime (Oct 2019)": ["20191022_013944_0p1a_SO_1", "20191028_003815_0p1a_SO_1"],
        # "SO-prime (Feb 2020)": ["20200226_024225_0p1a_SO_1", "20200227_041530_0p1a_SO_1"],
        # "SO-prime (Dec 2020)": ["20201224_011635_0p1a_SO_1", "20210102_092937_0p1a_SO_1"],
    },
    "lno": {
        # "Initial boresight (June 2016)":["20160613_001950_0p1a_LNO_1", "20160613_022203_0p1a_LNO_1"], \
        # "Initial boresight (June 2016)": ["20160615_233950_0p1a_LNO_1", "20160616_015450_0p1a_LNO_1"], \
        # "Refined boresight (Nov 2016)":["20161121_000420_0p1a_LNO_1", "20161121_021920_0p1a_LNO_1"], \
        # "MTP001":["201905", "20190704"],
        # "MTP015":["", ""],
        # "SO-prime (Jul 2020)":["20200724_125331_0p1a_LNO_1", "20200728_144718_0p1a_LNO_1"],
    },
    "uvis": {
        # "Before gyroless update (May 2024)": ["20240519_025013_1p0a_UVIS_CL", "20240521_134320_1p0a_UVIS_CL"], \
        # "Before gyroless update (Sep 2024)": ["20240915_141221_1p0a_UVIS_CL", "20240916_135327_1p0a_UVIS_CL"], \
        # "After gyroless update (Jan 2025)": ["20250113_132313_1p0a_UVIS_CL", "20250115_143500_1p0a_UVIS_CL"], \
        "After gyroless update (Feb 2025)": ["20250219_180516_1p0a_UVIS_CL", "20250221_191311_1p0a_UVIS_CL"], \
    },
}

if channel == "uvis":
    referenceFrame = "TGO_NOMAD_UVIS_OCC"
elif channel == "so":
    referenceFrame = "TGO_NOMAD_SO"
elif channel == "lno":
    referenceFrame = "TGO_NOMAD_LNO_OPS_OCC"
# referenceFrame = "TGO_SPACECRAFT"


def get_vector2(hdf5_filename):
    # read state vectors from file generated by WebGeoCalc
    dt, obs2SunVector = read_webgeocalc(hdf5_filename, "spkpos")
    print(dt[0])
    obs2SunUnitVector = obs2SunVector / np.tile(la.norm(obs2SunVector, axis=1), (3, 1)).T
    return -1 * obs2SunUnitVector  # -1 is there to switch the directions to be like in cosmographia


def get_vector(date_time, reference_frame):
    # calculate state vectors
    # print("SUN", date_time, reference_frame, SPICE_ABERRATION_CORRECTION, SPICE_OBSERVER)
    obs2SunVector = sp.spkpos("SUN", date_time, reference_frame, SPICE_ABERRATION_CORRECTION, SPICE_OBSERVER)[0]
    obs2SunUnitVector = obs2SunVector / sp.vnorm(obs2SunVector)
    return -1 * obs2SunUnitVector  # -1 is there to switch the directions to be like in cosmographia


if channel == "so":
    # plot all in subplots
    fig1, axes = plt.subplots(nrows=2, ncols=4, figsize=(FIG_X+5, FIG_Y+2))
    axes = axes.flatten()

    labelpad = 15
    fig1.add_subplot(111, frameon=False)
    plt.tick_params(labelcolor='none', top=False, bottom=False, left=False, right=False)

else:
    # plot just one at a time
    fig1, ax = plt.subplots(nrows=1, ncols=1, figsize=(FIG_X, FIG_Y),)
    labelpad = 0


if channel == "uvis":
    # no spatial/spectral dimensions for uvis
    plt.xlabel("%s SPICE FRAME X" % referenceFrame)
    plt.ylabel("%s SPICE FRAME Y" % referenceFrame, labelpad=labelpad)
else:
    plt.xlabel("%s SPICE FRAME X (Spatial direction)" % referenceFrame)
    plt.ylabel("%s SPICE FRAME Y (Spectral direction)" % referenceFrame, labelpad=labelpad)


for linescan_index, (title, hdf5_filenames) in enumerate(linescan_dict[channel].items()):

    xs = []
    ys = []
    zs = []

    if channel == "so":
        ax = axes[linescan_index]

    for scan_index, hdf5_filename in enumerate(hdf5_filenames):

        hdf5_file = open_hdf5_file(hdf5_filename, path=HDF5_PATH)

        detector_data_all = hdf5_file["Science/Y"][...]
        datetime_all = hdf5_file["Geometry/ObservationDateTime"][...]

        # convert data to times and boresights using spice
        et_all = np.asfarray([np.mean([utc2et(i[0]), utc2et(i[1])]) for i in datetime_all])

        if channel != "uvis":
            # get SO/LNO data
            detector_centre_line = DETECTOR_CENTRE_LINES[channel]
            window_top_all = hdf5_file["Channel/WindowTop"][...]
            window_height = hdf5_file["Channel/WindowHeight"][0]+1
            binning = hdf5_file["Channel/Binning"][0]+1
            sbsf = hdf5_file["Channel/BackgroundSubtraction"][0]

            print(window_top_all[0], window_height, binning, sbsf)

            if binning == 2:  # stretch array if binned
                detector_data_all = np.repeat(detector_data_all, 2, axis=1)
                detector_data_all /= 2
            if binning == 4:  # stretch array
                detector_data_all = np.repeat(detector_data_all, 4, axis=1)
                detector_data_all /= 4

            if sbsf == 0:
                # if background subtration not used, use rough reduction
                detector_data_all -= 50000.0

            if binning == 1 or binning == 2:
                # find which window top contains the line - this is not correct for binning
                unique_window_tops = list(set(window_top_all))
                for unique_window_top in unique_window_tops:
                    if unique_window_top <= detector_centre_line <= (unique_window_top + window_height):
                        centre_window_top = unique_window_top
                        centre_row_index = detector_centre_line - unique_window_top

                window_top_indices = np.where(window_top_all == centre_window_top)[0]
                detector_data_line = detector_data_all[window_top_indices, centre_row_index, :]
                et_line = et_all[window_top_indices]

            if binning == 4:
                # if all binned like an occultation
                detector_data_line = np.mean(detector_data_all[:, 7:9, :], axis=1)
                et_line = et_all[:]

            detector_line_mean = np.mean(detector_data_line[:, 160:240], axis=1)
            detector_line_min = (np.max(detector_line_mean) + np.min(detector_line_mean)) * 0.5
            # detector_line_max = np.max(detector_line_mean)
            detector_line_mean[detector_line_mean < detector_line_min] = detector_line_min
            # detector_line_mean[detector_line_mean > detector_line_max] = detector_line_max

        else:
            # if uvis, take mean of whole spectrum
            detector_data_line = np.mean(detector_data_all[:, :], axis=1)
            et_line = et_all[:]
            detector_line_mean = detector_data_line

        if PRINT_WGC_ETS:
            with open("%s_ets.txt" % hdf5_filename, "w") as f:
                for et in et_line:
                    f.write("%0.3f\n" % et)
            continue

        print("%s: max value = %0.0f, min value = %0.0f" % (hdf5_filename, np.max(detector_line_mean), np.min(detector_line_mean)))

        if not WGC:
            # calculate pointing with spiceypy
            unitVectors = np.asfarray([get_vector(datetime, referenceFrame) for datetime in et_line])

        else:
            # get pointing from file after calculating with WebGeoCalc
            unitVectors = get_vector2(hdf5_filename)
            print(et_line[0])


#        marker_colour = np.log(detector_line_mean)
        marker_colour = detector_line_mean

        if not MESHGRID:
            # plot raw points
            ax.scatter(unitVectors[:, 0], unitVectors[:, 1], c=marker_colour, alpha=1, cmap="gnuplot", linewidths=0)

        xs.extend(unitVectors[:, 0])
        ys.extend(unitVectors[:, 1])
        zs.extend(marker_colour)

    if not MESHGRID:
        # plot a circle where the Sun should be
        circle1 = plt.Circle((0, 0), 0.0016, color='yellow', alpha=0.1)
        ax.add_artist(circle1)
    ax.set_xlim([-grid_size, grid_size])
    ax.set_ylim([-grid_size, grid_size])
    ax.set_aspect("equal")
    ax.set_title("%s: %s & %s" % (title, hdf5_filenames[0][:8], hdf5_filenames[1][:8]))
    ax.set_title("%s" % (title))
    ax.grid()

    if MESHGRID:

        # plot meshgrid interpolation of the points
        xs = np.asfarray(xs)
        ys = np.asfarray(ys)
        zs = np.asfarray(zs)

        # Create grid values first.
        ngridx = 100
        ngridy = 100
        xi = np.linspace(-grid_size, grid_size, ngridx)
        yi = np.linspace(-grid_size, grid_size, ngridy)

        # Linearly interpolate the data (x, y) on a grid defined by (xi, yi).
        import matplotlib.tri as tri
        triang = tri.Triangulation(xs, ys)
        interpolator = tri.LinearTriInterpolator(triang, zs)
        Xi, Yi = np.meshgrid(xi, yi)
        zi = interpolator(Xi, Yi)

        ax.contourf(xi, yi, zi, levels=50, cmap="gnuplot")


fig1.tight_layout()

if SAVE_FIG:
    plt.savefig("%s_linescan_boresight.png" % channel, dpi=300)
# fig1.suptitle("SO Linescans")
